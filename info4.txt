#4.0 Create Account 1

- push to db after change in schema
npx prisma db push

#4.1 Create Account 2

- conditions in findFirst
-- or Example
const existingUser = await client.user.findFirst({
where: {
    OR: [{ userName }, { email }],
},
});

#4.2 Create Account 3

- install hash package
npm i bcrypt

- hash password

const uglyPassword = await bcrypt.hash(password, 10);

#4.3 seeProfile

- findunique only works on unique columns

- throw error in try catch when async mutation

#4.4 login

-check password with bcrypt
const passwordOk = await bcrypt.compare(password, user.password);

- issue token
-- use json web token
npm install jsonwebtoken

#4.5 login 2

- token sign
-- password for signing token to verify that this tokken was modifed by us
-- tokken is not secret information and anybody can see the data
const token = await jwt.sign({ id: user.id }, process.env.SECRET_KEY);

- jsonwebtoken has token expire function as well

#4.6 Divde and conquer
- divde each service into separate folders


#4.7 updateProfile

- undefined value in the prsima data do not go to database
-- following does not update to undefined in db

client.user.update({
        where: {
          id: 1,
        },
        data: {
          firstName,
          lastName,
          userName,
          email,
          password,
        },
      });

- a way to change parameter name without null problem
...(uglyPassword && { password: uglyPassword }),

#4.8 authentication 1

-- verify token
const { id } = await jwt.verify(token, process.env.SECRET_KEY);

#4.8 authentication 2

-send token automatically

- use httpHeaders to send token

- whatever put in context is available in every resolver if you put it in context
-- apollo server context part

-- put context in server
const server = new ApolloServer({
  schema,
  context: {
    token:
      "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwiaWF0IjoxNjc0NDA1NjY5fQ.tJpM8k_gyOyA3jAjreMF8lu1tsVJkSD52Jv4ontlU-I",
  },
});

#4.10 authentication 3

- context can be a function
-- get token from http headers

const server = new ApolloServer({
  schema,
  context: async ({ req }) => {
    return {
      loggedInUser: await getUser(req.headers.token),
    };
  },
});

#4.11 protect resolvers 1
- add error function in the context
- then use the function in mutation

#4.12
- put resolver insdie resolver
-- utils
export const protectedResolver =
  (ourResolver) => (root, args, context, info) => {
    if (!context.loggedInUser) {
      return {
        ok: false,
        error: "Please, login to perform this action",
      };
    }
    return ourResolver(root, args, context, info);
  };

-- put the resolver function inside the util function

#4.13 Recap

#4.14 File upload 1
- put resolvers and  typdefs seprately to get extra features from apollo instead of using excutable schema
-- you can use upload feature 

#4.15 file upload 2
- user node 14 version
nvm use v14.9.0
use apollo server version 2 for upload

- install altair
- use altair to test uploading file


#4.16 file upload 3
